//! Core meta/v1 types
//!
//! This module contains the fundamental metadata types used by all Kubernetes API objects.
//! These types are equivalent to `k8s.io/apimachinery/pkg/apis/meta/v1`.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

/// TypeMeta describes an individual object in an API response or request
/// with strings representing the type of the object and its API schema version.
///
/// Servers may infer this from the endpoint the client submits requests to.
/// This type is embedded in most Kubernetes API objects.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TypeMeta {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    ///
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub api_version: String,

    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated. In CamelCase.
    ///
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub kind: String,
}

impl TypeMeta {
    /// Creates a new TypeMeta with the given API version and kind.
    pub fn new(api_version: impl Into<String>, kind: impl Into<String>) -> Self {
        Self {
            api_version: api_version.into(),
            kind: kind.into(),
        }
    }
}

/// ObjectMeta is metadata that all persisted resources must have,
/// which includes all objects users must create.
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ObjectMeta {
    /// Name must be unique within a namespace. Is required when creating resources,
    /// although some resources may allow a client to request the generation of an
    /// appropriate name automatically.
    ///
    /// Name is primarily intended for creation idempotence and configuration definition.
    /// Cannot be updated.
    ///
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// GenerateName is an optional prefix, used by the server, to generate a unique
    /// name ONLY IF the Name field has not been provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generate_name: Option<String>,

    /// Namespace defines the space within which each name must be unique.
    /// An empty namespace is equivalent to the "default" namespace, but "default"
    /// is the canonical representation.
    ///
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,

    /// UID is the unique in time and space value for this object.
    /// It is typically generated by the server on successful creation of a resource.
    ///
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,

    /// An opaque value that represents the internal version of this object.
    /// Clients must treat these values as opaque and passed unmodified back to the server.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resource_version: Option<String>,

    /// A sequence number representing a specific generation of the desired state.
    /// Populated by the system. Read-only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generation: Option<i64>,

    /// CreationTimestamp is a timestamp representing the server time when this object
    /// was created. Clients may not set this value.
    ///
    /// Populated by the system. Read-only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub creation_timestamp: Option<DateTime<Utc>>,

    /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted.
    /// This field is set by the server when a graceful deletion is requested.
    ///
    /// Populated by the system when a graceful deletion is requested. Read-only.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion_timestamp: Option<DateTime<Utc>>,

    /// Number of seconds allowed for this object to gracefully terminate before
    /// it will be removed from the system. Only set when deletionTimestamp is also set.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub deletion_grace_period_seconds: Option<i64>,

    /// Map of string keys and values that can be used to organize and categorize objects.
    ///
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub labels: BTreeMap<String, String>,

    /// Annotations is an unstructured key value map stored with a resource.
    /// External tools can use this to store and retrieve arbitrary metadata.
    ///
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub annotations: BTreeMap<String, String>,

    /// List of objects depended by this object. If ALL objects in the list have
    /// been deleted, this object will be garbage collected.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub owner_references: Vec<OwnerReference>,

    /// Must be empty before the object is deleted from the registry.
    /// Each entry is an identifier for the responsible component that will remove
    /// the entry from the list.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub finalizers: Vec<String>,
}

impl ObjectMeta {
    /// Creates a new ObjectMeta with the given name.
    pub fn named(name: impl Into<String>) -> Self {
        Self {
            name: Some(name.into()),
            ..Default::default()
        }
    }

    /// Creates a new ObjectMeta with the given name and namespace.
    pub fn namespaced(name: impl Into<String>, namespace: impl Into<String>) -> Self {
        Self {
            name: Some(name.into()),
            namespace: Some(namespace.into()),
            ..Default::default()
        }
    }
}

/// OwnerReference contains enough information to let you identify an owning object.
/// An owning object must be in the same namespace as the dependent, or be cluster-scoped.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct OwnerReference {
    /// API version of the referent.
    pub api_version: String,

    /// Kind of the referent.
    pub kind: String,

    /// Name of the referent.
    pub name: String,

    /// UID of the referent.
    pub uid: String,

    /// If true, this reference points to the managing controller.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub controller: Option<bool>,

    /// If true, AND if the owner has the "foregroundDeletion" finalizer, then
    /// the owner cannot be deleted from the key-value store until this reference is removed.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub block_owner_deletion: Option<bool>,
}

/// LabelSelector is a label query over a set of resources.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LabelSelector {
    /// matchLabels is a map of {key,value} pairs.
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    pub match_labels: BTreeMap<String, String>,

    /// matchExpressions is a list of label selector requirements.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub match_expressions: Vec<LabelSelectorRequirement>,
}

/// LabelSelectorRequirement is a selector that contains values, a key, and an operator.
#[derive(Clone, Debug, Default, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LabelSelectorRequirement {
    /// key is the label key that the selector applies to.
    pub key: String,

    /// operator represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,

    /// values is an array of string values.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub values: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_meta_serialization() {
        let meta = TypeMeta::new("v1", "Pod");
        let json = serde_json::to_string(&meta).unwrap();
        assert!(json.contains("\"apiVersion\":\"v1\""));
        assert!(json.contains("\"kind\":\"Pod\""));
    }

    #[test]
    fn test_object_meta_serialization() {
        let meta = ObjectMeta::namespaced("my-pod", "default");
        let json = serde_json::to_string(&meta).unwrap();
        assert!(json.contains("\"name\":\"my-pod\""));
        assert!(json.contains("\"namespace\":\"default\""));
    }

    #[test]
    fn test_object_meta_with_labels() {
        let mut meta = ObjectMeta::named("my-pod");
        meta.labels.insert("app".to_string(), "nginx".to_string());

        let json = serde_json::to_string(&meta).unwrap();
        let parsed: ObjectMeta = serde_json::from_str(&json).unwrap();

        assert_eq!(parsed.labels.get("app"), Some(&"nginx".to_string()));
    }

    #[test]
    fn test_label_selector_roundtrip() {
        let mut selector = LabelSelector::default();
        selector.match_labels.insert("app".to_string(), "web".to_string());
        selector.match_expressions.push(LabelSelectorRequirement {
            key: "environment".to_string(),
            operator: "In".to_string(),
            values: vec!["production".to_string(), "staging".to_string()],
        });

        let json = serde_json::to_string(&selector).unwrap();
        let parsed: LabelSelector = serde_json::from_str(&json).unwrap();

        assert_eq!(selector, parsed);
    }
}
